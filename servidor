#!/usr/bin/env python3
import asyncio
import re
from tcp import Servidor, Conexao

apelidos = dict()

class Utils:
    def validar_nome(nome: bytes) -> bool:
        return re.match(br'^[a-zA-Z][a-zA-Z0-9_-]*$', nome) is not None

    def parse_cmd(linha: bytes, handler: str):
        # separa o comando dos argumentos
        _, *rest = linha.split(b' ', 1)
        args = rest[0] if rest else b''

        match handler:
            case 'ping' | 'nick':
                return args.lstrip(b':')
            case 'privmsg':
                dest, msg = args.split(b' ', 1)
                return dest, msg.lstrip(b':')
            case _:
                return args

class Handler:
    def handle_ping(conexao: Conexao, linha: bytes):
        args = Utils.parse_cmd(linha, 'ping')
        resposta = b':server PONG server :' + args + b'\r\n'
        conexao.enviar(resposta)

    # Exemplo futuro de handler de NICK:
    def handle_nick(conexao, linha: bytes):
        parts = linha.split(b' ', 1)
        token = parts[1] if len(parts) > 1 else b''
        token = token.lstrip(b':')
        if not Utils.validar_nome(token):
            resposta = b':server 432 ' + (conexao.apelido if conexao.apelido != b'' else b'*') + b' ' + token + b' :Erroneous nickname' + b'\r\n'
            conexao.enviar(resposta)
        elif token.upper() in apelidos:
            resposta = b':server 433 ' + (conexao.apelido if conexao.apelido != b'' else b'*') + b' ' + token + b' :Nickname is already in use' + b'\r\n'
            conexao.enviar(resposta)
        else:
            apelidos[token.upper()] = conexao
            if conexao.apelido == b'':
                resposta = (
                    b':server 001 ' + token + b' :Welcome' + b'\r\n' +
                    b':server 422 ' + token + b' :MOTD File is missing' + b'\r\n'
                )
                conexao.enviar(resposta) 
            else:
                del apelidos[conexao.apelido.upper()]
                resposta = b':' + conexao.apelido + b' NICK ' + token + b'\r\n'
                conexao.enviar(resposta) 
            conexao.apelido = token
    
    def handle_privmsg(conexao: Conexao, linha: bytes):
        dest, msg = Utils.parse_cmd(linha, 'privmsg')
        dest_up = dest.upper()

        target = apelidos.get(dest_up)        
        full_msg = (
            b':' + conexao.apelido +
            b' PRIVMSG ' + dest + b' :' +
            msg + b'\r\n'
        )
        target.enviar(full_msg)

    def handle_default(conexao, linha: bytes):
        print(conexao, linha)

class IRCServer:
    def __init__(self, porta: int = 6667):
        self.servidor = Servidor(porta)

    def start(self):
        self.servidor.registrar_monitor_de_conexoes_aceitas(self.conexao_aceita)
        print(f"[Servidor] Escutando em 0.0.0.0:{self.servidor.s.getsockname()[1]}")
        asyncio.get_event_loop().run_forever()

    def conexao_aceita(self, conexao: Conexao):
        print(f"[Conexão] {conexao} conectou")
        conexao.registrar_recebedor(self.dados_recebidos)

    def dados_recebidos(self, conexao: Conexao, dados: bytes):
        if dados == b'':
            return self.sair(conexao)

        conexao.buffer += dados
        linhas = conexao.buffer.split(b'\r\n')
        conexao.buffer = linhas[-1]

        for linha in linhas[:-1]:
            if not linha:
                continue
            if linha.upper().startswith(b'PING'):
                Handler.handle_ping(conexao, linha)
            elif linha.upper().startswith(b'NICK'):
                Handler.handle_nick(conexao, linha)
            elif linha.upper().startswith(b'PRIVMSG'):
                Handler.handle_privmsg(conexao, linha)
            else:
                Handler.handle_default(conexao, linha)

    def sair(self, conexao: Conexao):
        print(f"[Desconexão] {conexao} fechou")
        conexao.fechar()

if __name__ == "__main__":
    IRCServer(porta=6667).start()
